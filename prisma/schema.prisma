generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Product {
  id                 Int                 @id @default(autoincrement())
  name               String
  price              Float
  categoryId         Int?
  createdAt          DateTime            @default(now())
  description        String?
  imageUrl           String?
  imageKey           String?
  stock              Float?
  updatedAt          DateTime            @default(now()) @updatedAt
  brandId            Int?
  expirationDate     DateTime?
  imageTag           String?
  replenishAt        DateTime?
  dealerPrice        Float?
  srp                Float?
  allowPackSale      Boolean             @default(true)
  barcode            String?             @unique
  isActive           Boolean             @default(true)
  minStock           Float?
  packingStock       Int?
  sku                String?             @unique
  unitId             Int?
  packingUnitId      Int?
  locationId         Int?
  packingSize        Float?
  brand              Brand?              @relation(fields: [brandId], references: [id], onDelete: SetNull)
  category           Category?           @relation(fields: [categoryId], references: [id])
  location           Location?           @relation(fields: [locationId], references: [id], onDelete: SetNull)
  packingUnit        PackingUnit?        @relation("PackingUnit", fields: [packingUnitId], references: [id])
  unit               Unit?               @relation("RetailUnit", fields: [unitId], references: [id])
  productIndications ProductIndication[]
  productTags        ProductTag[]
  productTargets     ProductTarget[]
  saleItems          SaleItem[]
  tags               Tag[]               @relation("ProductTags")
  orderItems         OrderItem[]
}

model Sale {
  id        Int        @id @default(autoincrement())
  createdAt DateTime   @default(now())
  total     Float
  items     SaleItem[]
}

model SaleItem {
  id        Int     @id @default(autoincrement())
  saleId    Int
  productId Int
  quantity  Int
  price     Float
  product   Product @relation(fields: [productId], references: [id])
  sale      Sale    @relation(fields: [saleId], references: [id])
}

model Category {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  brands      Brand[]
  indications Indication[]
  products    Product[]
  targets     Target[]
}

model Tag {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  productTags ProductTag[]
  products    Product[]    @relation("ProductTags")
}

model ProductTag {
  productId Int
  tagId     Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  tag       Tag     @relation(fields: [tagId], references: [id])

  @@id([productId, tagId])
}

model Brand {
  id         Int       @id @default(autoincrement())
  name       String
  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id])
  products   Product[]

  @@unique([name, categoryId])
}

model Indication {
  id                 Int                 @id @default(autoincrement())
  name               String
  categoryId         Int
  category           Category            @relation(fields: [categoryId], references: [id])
  productIndications ProductIndication[]

  @@unique([name, categoryId])
}

model ProductIndication {
  productId    Int
  indicationId Int
  indication   Indication @relation(fields: [indicationId], references: [id], onDelete: Cascade)
  product      Product    @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@id([productId, indicationId])
}

model Target {
  id         Int      @id @default(autoincrement())
  name       String
  categoryId Int
  category   Category @relation(fields: [categoryId], references: [id])

  productTargets ProductTarget[]

  @@unique([name, categoryId])
}

model ProductTarget {
  productId Int
  targetId  Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  target    Target  @relation(fields: [targetId], references: [id], onDelete: Cascade)

  @@id([productId, targetId])
}

model Unit {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  retailFor Product[] @relation("RetailUnit")
}

model PackingUnit {
  id         Int       @id @default(autoincrement())
  name       String    @unique
  packingFor Product[] @relation("PackingUnit")
}

model Location {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  products Product[]
}

// ────────────── ORDER SLIP (Milestone 1) ──────────────

model ReceiptCounter {
  id       Int      @id @default(1)        // singleton (or per-branch later)
  current  Int      @default(0)
  updatedAt DateTime @updatedAt
}

model Order {
  id        Int         @id @default(autoincrement())
  orderCode String      @unique
  status    OrderStatus @default(UNPAID)

  // Snapshot totals (no discounts yet)
  subtotal            Float
  totalBeforeDiscount Float

  // Slip meta
  printCount Int      @default(1)
  printedAt  DateTime
  expiryAt   DateTime
  terminalId String?

  // Relations
  items OrderItem[]
  payments  Payment[] 

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Cashier locking ---
  lockedAt DateTime?
  lockedBy String? // cashier code/email/name
  lockNote String? // optional reason
  

 // Receipt fields (set when PAID)
  paidAt     DateTime?
  receiptNo  String?   @unique   // set when PAID


  @@index([status, expiryAt])
  @@index([lockedAt])
  @@index([status])
  @@index([expiryAt])
}

model OrderItem {
  id      Int   @id @default(autoincrement())
  orderId Int
  order   Order @relation(fields: [orderId], references: [id])

  // Keep link to product but also snapshot name/price for immutability
  productId Int
  product   Product @relation(fields: [productId], references: [id])

  name      String
  qty       Float // allows 0.25, 0.5 kg etc.
  unitPrice Float
  lineTotal Float

  @@index([orderId])
}

model Payment {
  id        Int      @id @default(autoincrement())
  orderId   Int
  order     Order    @relation(fields: [orderId], references: [id])
  method    PaymentMethod
  amount    Float
  refNo     String?   // GCash ref, last 4 of card, etc.
  createdAt DateTime  @default(now())

  @@index([orderId])

  
}

// ── NEW (singleton counter for receipts) ────────────────────


enum PaymentMethod {
  CASH
  GCASH
  CARD
  SPLIT // optional: if you want a “meta” method; otherwise just record multiple rows
}

enum OrderStatus {
  DRAFT
  UNPAID
  PAID
  CANCELLED
  VOIDED
}
