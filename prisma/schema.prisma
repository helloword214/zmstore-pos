generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Product {
  id                 Int                 @id @default(autoincrement())
  name               String
  price              Decimal             @db.Decimal(10, 2)
  categoryId         Int?
  createdAt          DateTime            @default(now())
  description        String?
  imageUrl           String?
  imageKey           String?
  stock              Decimal?            @db.Decimal(12, 3)
  updatedAt          DateTime            @default(now()) @updatedAt
  brandId            Int?
  expirationDate     DateTime?
  imageTag           String?
  replenishAt        DateTime?
  dealerPrice        Decimal?            @db.Decimal(10, 2)
  srp                Decimal?            @db.Decimal(10, 2)
  allowPackSale      Boolean             @default(true)
  barcode            String?             @unique
  isActive           Boolean             @default(true)
  minStock           Decimal?            @db.Decimal(12, 3)
  packingStock       Int?
  sku                String?             @unique
  unitId             Int?
  packingUnitId      Int?
  locationId         Int?
  packingSize        Decimal?            @db.Decimal(12, 3)
  brand              Brand?              @relation(fields: [brandId], references: [id], onDelete: SetNull)
  category           Category?           @relation(fields: [categoryId], references: [id])
  location           Location?           @relation(fields: [locationId], references: [id], onDelete: SetNull)
  packingUnit        PackingUnit?        @relation("PackingUnit", fields: [packingUnitId], references: [id])
  unit               Unit?               @relation("RetailUnit", fields: [unitId], references: [id])
  productIndications ProductIndication[]
  productTags        ProductTag[]
  productTargets     ProductTarget[]
  saleItems          SaleItem[]
  tags               Tag[]               @relation("ProductTags")
  // back-relation to customer-specific pricing rules
  customerItemPrices CustomerItemPrice[] @relation("CustomerItemPricesOnProduct")
  orderItems         OrderItem[]

  // back-relations for new models
  stockMovements StockMovement[]
  runAdhocSales  RunAdhocSale[]

  // NEW: lines in run receipts
  runReceiptLines RunReceiptLine[]
}

model Sale {
  id        Int        @id @default(autoincrement())
  createdAt DateTime   @default(now())
  total     Float
  items     SaleItem[]
}

model SaleItem {
  id        Int     @id @default(autoincrement())
  saleId    Int
  productId Int
  quantity  Int
  price     Float
  product   Product @relation(fields: [productId], references: [id])
  sale      Sale    @relation(fields: [saleId], references: [id])
}

model Category {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  brands      Brand[]
  indications Indication[]
  products    Product[]
  targets     Target[]
}

model Tag {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  productTags ProductTag[]
  products    Product[]    @relation("ProductTags")
}

model ProductTag {
  productId Int
  tagId     Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  tag       Tag     @relation(fields: [tagId], references: [id])

  @@id([productId, tagId])
}

model Brand {
  id         Int       @id @default(autoincrement())
  name       String
  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id])
  products   Product[]

  @@unique([name, categoryId])
}

model Indication {
  id                 Int                 @id @default(autoincrement())
  name               String
  categoryId         Int
  category           Category            @relation(fields: [categoryId], references: [id])
  productIndications ProductIndication[]

  @@unique([name, categoryId])
}

model ProductIndication {
  productId    Int
  indicationId Int
  indication   Indication @relation(fields: [indicationId], references: [id], onDelete: Cascade)
  product      Product    @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@id([productId, indicationId])
}

model Target {
  id         Int      @id @default(autoincrement())
  name       String
  categoryId Int
  category   Category @relation(fields: [categoryId], references: [id])

  productTargets ProductTarget[]

  @@unique([name, categoryId])
}

model ProductTarget {
  productId Int
  targetId  Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  target    Target  @relation(fields: [targetId], references: [id], onDelete: Cascade)

  @@id([productId, targetId])
}

model Unit {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  retailFor Product[] @relation("RetailUnit")
}

model PackingUnit {
  id         Int       @id @default(autoincrement())
  name       String    @unique
  packingFor Product[] @relation("PackingUnit")
}

model Location {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  products Product[]
}

// ────────────── ORDER SLIP (Milestone 1) ──────────────

model ReceiptCounter {
  id        Int      @id @default(1) // singleton (or per-branch later)
  current   Int      @default(0)
  updatedAt DateTime @updatedAt
}

model Customer {
  id            Int     @id @default(autoincrement())
  firstName     String
  middleName    String?
  lastName      String
  suffix        String?
  alias         String?
  phone         String? @unique
  email         String?
  isActive      Boolean @default(true)
  notes         String?
  creditLimit   Float?
  loyaltyPoints Int     @default(0)
  tier          String?

  addresses          CustomerAddress[]
  orders             Order[]
  cylinderLoans      CylinderLoan[]
  customerItemPrices CustomerItemPrice[]

  // NEW: run receipts (roadside or parent receipts)
  runReceipts RunReceipt[] @relation("CustomerRunReceipts")

  // CCS back-relations
  clearanceCases ClearanceCase[] @relation("CustomerClearanceCases")
  customerAr     CustomerAr[]    @relation("CustomerArLedger")

  @@index([phone])
  @@index([alias])
  @@index([lastName, firstName])
}

model CustomerAddress {
  id         Int      @id @default(autoincrement())
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  label      String
  line1      String

  // snapshots (keep!)
  barangay String
  city     String
  province String
  purok    String?

  // FKs (all optional for now)
  provinceId  Int?
  provinceRef Province? @relation(fields: [provinceId], references: [id], onDelete: SetNull)

  municipalityId Int?
  municipality   Municipality? @relation(fields: [municipalityId], references: [id], onDelete: SetNull)

  barangayId  Int?
  barangayRef Barangay? @relation(fields: [barangayId], references: [id], onDelete: SetNull)

  zoneId Int?
  zone   Zone? @relation(fields: [zoneId], references: [id], onDelete: SetNull)

  landmarkId  Int?
  landmarkRef Landmark? @relation("LandmarkToAddresses", fields: [landmarkId], references: [id], onDelete: SetNull)

  postalCode     String?
  landmark       String?
  geoLat         Float?
  geoLng         Float?
  photoUrl       String?
  photoKey       String?
  photoUpdatedAt DateTime?

  deliveryOrders Order[] @relation("OrderDeliveryAddress")
  photos         CustomerAddressPhoto[]

  @@index([provinceId])
  @@index([municipalityId])
  @@index([barangayId])
  @@index([zoneId])
  @@index([landmarkId])
}

model CustomerAddressPhoto {
  id                Int             @id @default(autoincrement())
  customerAddressId Int
  slot              Int
  fileKey           String
  fileUrl           String
  mimeType          String
  sizeBytes         Int
  caption           String?
  uploadedAt        DateTime        @default(now())
  createdAt         DateTime        @default(now())

  customerAddress CustomerAddress @relation(fields: [customerAddressId], references: [id], onDelete: Cascade)

  @@unique([customerAddressId, slot])
  @@index([customerAddressId, uploadedAt])
}

model CustomerItemPrice {
  id         Int       @id @default(autoincrement())
  customerId Int
  productId  Int
  unitKind   UnitKind
  mode       PriceMode
  value      Decimal   @db.Decimal(10, 2) // meaning depends on mode
  note       String?
  active     Boolean   @default(true)
  startsAt   DateTime?
  endsAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  product  Product  @relation("CustomerItemPricesOnProduct", fields: [productId], references: [id], onDelete: Cascade)

  @@unique([customerId, productId, unitKind, startsAt, endsAt])
  @@index([customerId, productId, unitKind])
  @@index([active, startsAt, endsAt])
}

model Order {
  id        Int         @id @default(autoincrement())
  orderCode String      @unique
  status    OrderStatus @default(UNPAID)

  // Channel: pickup vs delivery
  channel OrderChannel @default(PICKUP)

  // Snapshot totals (no discounts yet)
  subtotal            Float?
  totalBeforeDiscount Float?

  // Slip meta
  printCount Int      @default(1)
  printedAt  DateTime
  expiryAt   DateTime
  terminalId String?

  // Relations
  items      OrderItem[]
  payments   Payment[]
  customerId Int?
  customer   Customer?   @relation(fields: [customerId], references: [id])

  // (optional) Delivery address reference for delivery orders
  deliveryAddressId Int?
  deliveryAddress   CustomerAddress? @relation("OrderDeliveryAddress", fields: [deliveryAddressId], references: [id], onDelete: SetNull)
  deliverTo         String? // snapshot: "Name — full address"
  deliverPhone      String? // snapshot contact for rider
  deliverLandmark   String? // snapshot landmark text
  deliverGeoLat     Float? // snapshot coords (optional)
  deliverGeoLng     Float? // snapshot coords (optional)
  deliverPhotoUrl   String? // snapshot photo (optional)
  deliverPhotoKey   String? // snapshot photo storage key (optional)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Cashier locking ---
  lockedAt DateTime?
  lockedBy String? // cashier code/email/name
  lockNote String? // optional reason

  // --- Utang / Credit fields ---
  isOnCredit         Boolean   @default(false) // mark as utang/AR
  dueDate            DateTime? // optional promise-to-pay date
  releaseWithBalance Boolean   @default(false) // goods released before full payment
  releasedApprovedBy String? // who approved the release
  releasedAt         DateTime? // when goods left store

  // --- Delivery / Fulfillment ---
  fulfillmentStatus FulfillmentStatus? @default(NEW)
  dispatchedAt      DateTime?
  deliveredAt       DateTime?
  riderName         String? // free text for now; future: Staff/User relation

  // --- Staging (Delivery Dispatch Staging) ---
  stagedAt        DateTime?
  riderId         Int? // relational rider (Employee)
  vehicleId       Int? // relational vehicle
  vehicleName     String? // snapshot (for ticket history)
  loadoutSnapshot Json? // [{ productId, name, qty, unit? }]

  // Named relations to avoid ambiguity
  rider   Employee? @relation("OrderRider", fields: [riderId], references: [id], onDelete: SetNull)
  vehicle Vehicle?  @relation("OrderVehicle", fields: [vehicleId], references: [id], onDelete: SetNull)

  // Back-relations
  overrideLogs OverrideLog[] @relation("OrderOverrideLogs")

  // Receipt fields (set when PAID)
  paidAt    DateTime?
  receiptNo String?   @unique // set when PAID

  // Back-relation for DeliveryRunOrder join table
  runOrders DeliveryRunOrder[] @relation("OrderRunLinks")

  remitGroup String? @db.VarChar(64) // group tag for rider remit batches

  /// If this order was created from a rider “sold from load” row during a remit,
  /// link it back to the main DELIVERY order being remitted.
  remitParentId Int?
  remitParent   Order? @relation("RemitParentChildren", fields: [remitParentId], references: [id])

  /// Children created from the parent remit
  remitChildren Order[] @relation("RemitParentChildren")

  // NEW: run receipts linked to this order as a parent receipt
  runReceipts RunReceipt[] @relation("OrderRunReceipts")

  /// OPTION B: If this order was generated from a roadside RunReceipt (kind=ROAD),
  /// link back to the exact origin receipt. This makes cashier "expected rider cash"
  /// deterministic and removes query-param / recompute dependency.
  originRunReceiptId Int?
  originRunReceipt   RunReceipt? @relation("OriginRunReceiptToOrders", fields: [originRunReceiptId], references: [id], onDelete: SetNull)

  // CCS back-relations
  clearanceCases ClearanceCase[] @relation("OrderClearanceCases")
  customerAr     CustomerAr[]    @relation("OrderCustomerAr")

  @@index([remitGroup])
  @@index([originRunReceiptId])
  @@index([status, expiryAt])
  @@index([lockedAt])
  @@index([status])
  @@index([expiryAt])
  @@index([customerId])
  @@index([channel])
  @@index([fulfillmentStatus])
  @@index([deliveryAddressId])
  @@index([deliverGeoLat, deliverGeoLng])
  @@index([riderId])
  @@index([vehicleId])
}

model OrderItem {
  id      Int   @id @default(autoincrement())
  orderId Int
  order   Order @relation(fields: [orderId], references: [id])

  // Keep link to product but also snapshot name/price for immutability
  productId Int
  product   Product @relation(fields: [productId], references: [id])

  name      String
  qty       Decimal @db.Decimal(10, 2)
  unitPrice Decimal @db.Decimal(10, 2)
  lineTotal Decimal @db.Decimal(10, 2)

  /// Audit: base price at time of freeze (SRP/price)
  baseUnitPrice  Decimal? @db.Decimal(10, 2)
  /// Audit: baseUnitPrice - unitPrice (>=0)
  discountAmount Decimal? @db.Decimal(10, 2)

  // DB already has this; make it visible to Prisma
  unitKind UnitKind?

  // discount audit
  pricePolicy        String? // "BASE", "PER_ITEM", or "RULE:<id/type>"
  allowedUnitPrice   Decimal? @db.Decimal(10, 2)
  discountApprovedBy String? // if cashier priced below allowed

  // --- LPG minimal hooks (per line) ---
  isLpg            Boolean      @default(false)
  brandAtSale      String? // snapshot brand for receipt (esp. Catgas family)
  lpgSwapKind      LpgSwapKind?
  lpgEmptyReturned Float? // empties received at handover/delivery
  lpgLoaned        Float? // cylinders loaned (no empty returned)

  @@index([orderId])
}

model Payment {
  id        Int           @id @default(autoincrement())
  orderId   Int
  order     Order         @relation(fields: [orderId], references: [id])
  method    PaymentMethod
  amount    Decimal       @db.Decimal(12, 2)
  refNo     String? // GCash ref, last 4 of card, etc.
  createdAt DateTime      @default(now())

  /// NEW: what the cashier/rider actually handed
  tendered Decimal? @db.Decimal(10, 2)
  /// NEW: change given back
  change   Decimal? @db.Decimal(10, 2)

  // --- AUDIT TAGS (for shift tracing) ---
  shiftId   Int?
  cashierId Int?

  shift   CashierShift? @relation(fields: [shiftId], references: [id])
  // name the relation to disambiguate from other User relations
  cashier User?         @relation("UserPaymentsProcessed", fields: [cashierId], references: [id])

  @@index([orderId])
  @@index([shiftId])
  @@index([cashierId, createdAt])
}

// Track borrowed LPG cylinders per customer
model CylinderLoan {
  id          Int       @id @default(autoincrement())
  customerId  Int
  customer    Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  brandFamily String // e.g. "CATGAS", "BRANDED" (can convert to enum later)
  qty         Float // allow fractional if needed (e.g., partial deposit logic later)
  openedAt    DateTime  @default(now())
  closedAt    DateTime?
  notes       String?

  @@index([customerId, closedAt])
}

// ── NEW (singleton counter for receipts) ────────────────────

enum PaymentMethod {
  CASH
  FUND_TRANSFER
  CARD
  SPLIT // optional: if you want a “meta” method; otherwise just record multiple rows
  INTERNAL_CREDIT
}

enum OrderStatus {
  DRAFT
  UNPAID
  PAID
  PARTIALLY_PAID
  CANCELLED
  VOIDED
}

enum UnitKind {
  RETAIL
  PACK
}

enum PriceMode {
  FIXED_PRICE // set the exact unit price
  FIXED_DISCOUNT // subtract a fixed amount (per unit)
  PERCENT_DISCOUNT // subtract % of base price (per unit)
}

// --- NEW: channel + fulfillment + LPG swap kinds ---
enum OrderChannel {
  PICKUP
  DELIVERY
}

enum FulfillmentStatus {
  NEW
  STAGED
  PICKING
  PACKING
  DISPATCHED
  DELIVERED
  ON_HOLD
}

enum LpgSwapKind {
  REFILL
  SWAP_CATGAS
  UPGRADE_BRANDED
}

// ────────────── NEW: Workforce & Fleet ──────────────

model Employee {
  id            Int          @id @default(autoincrement())
  firstName     String
  middleName    String?
  lastName      String
  alias         String?
  birthDate     DateTime?
  phone         String?      @unique
  email         String?      @unique
  sssNumber     String?
  pagIbigNumber String?
  licenseNumber String?
  licenseExpiry DateTime?
  role          EmployeeRole @default(STAFF)
  active        Boolean      @default(true)

  defaultVehicleId Int?
  defaultVehicle   Vehicle? @relation("DefaultVehicle", fields: [defaultVehicleId], references: [id], onDelete: SetNull)

  // Back-relations
  ordersAsRider  Order[]            @relation("OrderRider")
  runsAsRider    DeliveryRun[]      @relation("RunRider")
  user           User?
  address        EmployeeAddress?
  documents      EmployeeDocument[]
  riderVariances RiderRunVariance[]

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  RiderCharge RiderCharge[]

  @@index([role, active])
}

model EmployeeAddress {
  id             Int    @id @default(autoincrement())
  employeeId     Int    @unique
  line1          String
  provinceId     Int
  municipalityId Int
  barangayId     Int
  zoneId         Int?
  landmarkId     Int?

  // snapshot fields (audit-safe text copy)
  province String
  city     String
  barangay String
  purok    String?

  postalCode String?
  landmark   String?
  geoLat     Float?
  geoLng     Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  employee     Employee     @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  provinceRef  Province     @relation(fields: [provinceId], references: [id], onDelete: Restrict)
  municipality Municipality @relation(fields: [municipalityId], references: [id], onDelete: Restrict)
  barangayRef  Barangay     @relation(fields: [barangayId], references: [id], onDelete: Restrict)
  zone         Zone?        @relation(fields: [zoneId], references: [id], onDelete: SetNull)
  landmarkRef  Landmark?    @relation("LandmarkToEmployeeAddresses", fields: [landmarkId], references: [id], onDelete: SetNull)

  @@index([provinceId])
  @@index([municipalityId])
  @@index([barangayId])
  @@index([zoneId])
  @@index([landmarkId])
}

enum EmployeeRole {
  STAFF
  RIDER
  MANAGER
}

enum EmployeeDocumentType {
  BARANGAY_CLEARANCE
  VALID_ID
  DRIVER_LICENSE_SCAN
  POLICE_CLEARANCE
  NBI_CLEARANCE
  PHOTO_2X2
  RESUME
  OTHER
}

model Vehicle {
  id                    Int         @id @default(autoincrement())
  name                  String
  type                  VehicleType
  plateNumber           String?
  orNumber              String?
  crNumber              String?
  ltoRegistrationExpiry DateTime?
  capacityUnits         Float? // e.g., "LPG unit slots" default capacity
  notes                 String?
  active                Boolean     @default(true)

  // backrefs
  defaultForEmployees Employee[]               @relation("DefaultVehicle")
  usedOnOrders        Order[]                  @relation("OrderVehicle")
  runs                DeliveryRun[]            @relation("RunVehicle")
  capacityProfiles    VehicleCapacityProfile[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, type])
  @@index([active])
}

enum VehicleType {
  TRICYCLE
  MOTORCYCLE
  SIDECAR
  MULTICAB
  VAN
  OTHER
}

// Optional finer-grained capacity per product/tag/category
model VehicleCapacityProfile {
  id        Int    @id @default(autoincrement())
  vehicleId Int
  key       String // e.g., "TAG:LPG", "CAT:11KG", "PRODUCT:123"
  maxUnits  Float

  vehicle Vehicle @relation(fields: [vehicleId], references: [id], onDelete: Cascade)

  @@unique([vehicleId, key])
  @@index([vehicleId])
}

model EmployeeDocument {
  id           Int                  @id @default(autoincrement())
  employeeId   Int
  docType      EmployeeDocumentType
  fileKey      String
  fileUrl      String
  mimeType     String
  sizeBytes    Int
  expiresAt    DateTime?
  uploadedById Int?
  notes        String?
  uploadedAt   DateTime             @default(now())
  createdAt    DateTime             @default(now())

  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  uploadedBy User?    @relation("EmployeeDocumentsUploadedBy", fields: [uploadedById], references: [id], onDelete: SetNull)

  @@index([employeeId, docType, uploadedAt])
  @@index([docType, expiresAt])
  @@index([uploadedById, uploadedAt])
}

// ────────────── NEW: Stock Movements for Loadout (Milestone 2) ──────────────

model StockMovement {
  id           Int               @id @default(autoincrement())
  type         StockMovementType
  productId    Int
  qty          Decimal           @db.Decimal(12, 3)
  refKind      StockRefKind?
  refId        Int? // Order.id or DeliveryRun.id depending on refKind
  locationFrom String?
  locationTo   String?

  createdAt DateTime @default(now())
  notes     String?

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([type, productId])
  @@index([refKind, refId])
}

enum StockMovementType {
  LOADOUT_OUT // Movement Out: Loadout to rider
  RETURN_IN // Movement In: Return from rider
  ADHOC_SALE_OUT // Optional: ad-hoc sale deduction (from run loadout)
}

enum StockRefKind {
  ORDER
  RUN
}

// ────────────── NEW: Delivery Runs (Milestone 3) ──────────────

model DeliveryRun {
  id              Int       @id @default(autoincrement())
  runCode         String    @unique
  status          RunStatus @default(PLANNED)
  riderId         Int?
  vehicleId       Int?
  loadoutSnapshot Json? // snapshot at dispatch time
  notes           String?

  createdAt    DateTime  @default(now())
  dispatchedAt DateTime?
  closedAt     DateTime?

  // NEW: Rider check-in snapshot before remit
  riderCheckinSnapshot Json?
  riderCheckinAt       DateTime?
  riderCheckinNotes    String?

  rider   Employee? @relation("RunRider", fields: [riderId], references: [id], onDelete: SetNull)
  vehicle Vehicle?  @relation("RunVehicle", fields: [vehicleId], references: [id], onDelete: SetNull)

  orders         DeliveryRunOrder[]
  adhocSales     RunAdhocSale[]
  overrideLogs   OverrideLog[]      @relation("RunOverrideLogs")
  riderVariances RiderRunVariance[]

  // NEW: receipt-level grouping for rider check-in / manager review
  receipts    RunReceipt[]
  RiderCharge RiderCharge[]

  // CCS back-relations
  clearanceCases ClearanceCase[] @relation("RunClearanceCases")
  customerAr     CustomerAr[]    @relation("RunCustomerAr")

  @@index([status])
  @@index([riderId])
  @@index([vehicleId])
}

enum RunReceiptKind {
  ROAD
  PARENT
}

enum RunReceiptStatus {
  DRAFT // encoded by rider
  REVIEWED // manager approved/check
  SETTLED // cashier finished
}

model RunReceipt {
  id    Int            @id @default(autoincrement())
  runId Int
  kind  RunReceiptKind @default(ROAD)

  /// A stable grouping key (human-friendly or generated)
  /// Example: "RR-0001" (per run), or UUID short.
  receiptKey String @db.VarChar(64)

  /// Optional link to an existing Order (for parent orders)
  parentOrderId Int?
  parentOrder   Order? @relation("OrderRunReceipts", fields: [parentOrderId], references: [id], onDelete: SetNull)

  /// OPTION B reverse link: Orders created from this receipt (usually 0 or 1)
  generatedOrders Order[] @relation("OriginRunReceiptToOrders")

  /// Customer reference (preferred) + snapshots (fallback)
  customerId    Int?
  customer      Customer? @relation("CustomerRunReceipts", fields: [customerId], references: [id], onDelete: SetNull)
  customerName  String?
  customerPhone String?

  /// The actual cash rider collected for this receipt
  cashCollected Decimal @default(0) @db.Decimal(12, 2)

  /// Optional note (e.g., "used own change", "sukli fund", etc.)
  note String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  run   DeliveryRun      @relation(fields: [runId], references: [id], onDelete: Cascade)
  lines RunReceiptLine[]

  status     RunReceiptStatus @default(DRAFT)
  reviewedAt DateTime?
  settledAt  DateTime?

  // v2.6: operational VOIDED (after manager REJECT + goods not released)
  // VOIDED is treated as "settled" for submit/remit gates (logic-level).
  voidedAt   DateTime?
  voidReason String?   @db.VarChar(200)
  voidedById Int?
  voidedBy   User?     @relation("RunReceiptVoidedBy", fields: [voidedById], references: [id], onDelete: SetNull)

  RiderRunVariance RiderRunVariance?

  // CCS back-relation
  clearanceCases ClearanceCase[] @relation("ReceiptClearanceCases")

  @@unique([runId, receiptKey])
  @@index([runId])
  @@index([kind])
  @@index([customerId])
  @@index([parentOrderId])
}

model RunReceiptLine {
  id        Int @id @default(autoincrement())
  receiptId Int

  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  /// Snapshot fields (keep for immutability)
  name      String
  qty       Decimal   @db.Decimal(12, 3)
  unitPrice Decimal   @db.Decimal(10, 2)
  lineTotal Decimal   @db.Decimal(12, 2)
  unitKind  UnitKind? // <-- add this (enum should exist)

  // ✅ Frozen SRP/base at time of check-in (audit trail)
  baseUnitPrice  Decimal? // SRP or product.price fallback
  discountAmount Decimal? // baseUnitPrice - unitPrice (>=0)

  createdAt DateTime @default(now())

  receipt RunReceipt @relation(fields: [receiptId], references: [id], onDelete: Cascade)

  @@index([receiptId])
  @@index([productId])
}

enum RunStatus {
  PLANNED
  DISPATCHED
  CHECKED_IN
  CLOSED // tapos na kay Store Manager
  SETTLED // tapos na kay Cashier (remit done)
  CANCELLED
}

// Join table: many orders per run
model DeliveryRunOrder {
  runId    Int
  orderId  Int
  sequence Int? // optional stop ordering

  run   DeliveryRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  order Order       @relation("OrderRunLinks", fields: [orderId], references: [id], onDelete: Cascade)

  @@id([runId, orderId])
  @@index([orderId])
}

// Minimal ad-hoc sale lines against a run loadout
model RunAdhocSale {
  id        Int      @id @default(autoincrement())
  runId     Int
  productId Int
  qty       Decimal  @db.Decimal(12, 3)
  unitPrice Decimal  @db.Decimal(10, 2)
  lineTotal Decimal  @db.Decimal(12, 2)
  createdAt DateTime @default(now())

  run     DeliveryRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  product Product     @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([runId])
  @@index([productId])
}

// ────────────── NEW: Permissions & Overrides (Milestone 4) ──────────────
model OverrideLog {
  id         Int          @id @default(autoincrement())
  kind       OverrideKind
  orderId    Int?
  runId      Int?
  approvedBy String // PIN/name or user code
  reason     String?
  createdAt  DateTime     @default(now())

  // Named relations + back-relations exist on Order/DeliveryRun
  order Order?       @relation("OrderOverrideLogs", fields: [orderId], references: [id], onDelete: SetNull)
  run   DeliveryRun? @relation("RunOverrideLogs", fields: [runId], references: [id], onDelete: SetNull)

  @@index([orderId])
  @@index([runId])
  @@index([kind, createdAt])
}

// ────────────── Rider Cash Variance (Shortages / Over) ──────────────

enum RiderVarianceStatus {
  OPEN
  MANAGER_APPROVED
  RIDER_ACCEPTED
  WAIVED
  PARTIALLY_SETTLED
  CLOSED
}

enum RiderVarianceResolution {
  CHARGE_RIDER
  WAIVE
  INFO_ONLY
}

// ────────────── Rider Charges Ledger (OPTION B) ──────────────
// Separate from variances: this is the actual "utang/charge" with payments + balance.
enum RiderChargeStatus {
  OPEN
  PARTIALLY_SETTLED
  SETTLED
  WAIVED
}

enum RiderChargePaymentMethod {
  CASH
  FUND_TRANSFER
  PAYROLL_DEDUCTION
  ADJUSTMENT
}

model RiderCharge {
  id Int @id @default(autoincrement())

  /// Optional: one charge per variance (common case)
  varianceId Int?              @unique
  variance   RiderRunVariance? @relation(fields: [varianceId], references: [id], onDelete: SetNull)

  /// Optional: link to run if charge is run-related
  runId   Int?
  riderId Int

  /// Positive amount owed by rider
  amount Decimal @db.Decimal(12, 2)

  status RiderChargeStatus @default(OPEN)
  note   String?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  settledAt DateTime?

  createdById Int?
  createdBy   User? @relation("RiderChargesCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  rider Employee     @relation(fields: [riderId], references: [id], onDelete: Restrict)
  run   DeliveryRun? @relation(fields: [runId], references: [id], onDelete: SetNull)

  payments RiderChargePayment[]

  @@index([riderId, status])
  @@index([runId])
  @@index([createdAt])
}

model RiderChargePayment {
  id       Int @id @default(autoincrement())
  chargeId Int

  amount Decimal                  @db.Decimal(12, 2)
  method RiderChargePaymentMethod @default(CASH)
  note   String?
  refNo  String?

  createdAt DateTime @default(now())

  /// Optional audit hooks (who/shift)
  shiftId   Int?
  cashierId Int?

  charge  RiderCharge   @relation(fields: [chargeId], references: [id], onDelete: Cascade)
  shift   CashierShift? @relation(fields: [shiftId], references: [id], onDelete: SetNull)
  cashier User?         @relation("RiderChargePaymentsProcessed", fields: [cashierId], references: [id], onDelete: SetNull)

  @@index([chargeId])
  @@index([cashierId, createdAt])
}

// ────────────── Cashier Shift Variance (Manager-side audit) ──────────────

enum CashierVarianceStatus {
  OPEN
  MANAGER_APPROVED
  WAIVED
  CLOSED
}

enum CashierVarianceResolution {
  CHARGE_CASHIER
  WAIVE
  INFO_ONLY
}

model CashierShiftVariance {
  id      Int          @id @default(autoincrement())
  shiftId Int          @unique
  shift   CashierShift @relation(fields: [shiftId], references: [id], onDelete: Cascade)

  expected Decimal @db.Decimal(12, 2)
  counted  Decimal @db.Decimal(12, 2)
  variance Decimal @db.Decimal(12, 2) // counted - expected

  status     CashierVarianceStatus      @default(OPEN)
  resolution CashierVarianceResolution?
  note       String?

  createdAt  DateTime  @default(now())
  resolvedAt DateTime?

  managerApprovedAt   DateTime?
  managerApprovedById Int?
  managerApprovedBy   User?     @relation("ManagerApprovedCashierVariances", fields: [managerApprovedById], references: [id], onDelete: SetNull)

  // OPTIONAL: ledger link (created when resolution=CHARGE_CASHIER)
  CashierCharge CashierCharge?

  @@index([status])
  @@index([managerApprovedAt])
}

// ────────────── Cashier Charges Ledger (like RiderCharge) ──────────────
enum CashierChargeStatus {
  OPEN
  PARTIALLY_SETTLED
  SETTLED
  WAIVED
}

enum CashierChargePaymentMethod {
  CASH
  FUND_TRANSFER
  PAYROLL_DEDUCTION
  ADJUSTMENT
}

model CashierCharge {
  id Int @id @default(autoincrement())

  /// One charge per cashier variance (common case)
  varianceId Int?                  @unique
  variance   CashierShiftVariance? @relation(fields: [varianceId], references: [id], onDelete: SetNull)

  /// Optional: link to shift (nice for audit trail)
  shiftId   Int?
  cashierId Int

  /// Positive amount owed by cashier (store absolute value here)
  amount Decimal @db.Decimal(12, 2)

  status CashierChargeStatus @default(OPEN)
  note   String?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  settledAt DateTime?

  createdById Int?
  createdBy   User? @relation("CashierChargesCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  cashier User          @relation("CashierChargesOnUser", fields: [cashierId], references: [id], onDelete: Restrict)
  shift   CashierShift? @relation(fields: [shiftId], references: [id], onDelete: SetNull)

  payments CashierChargePayment[]

  @@index([cashierId, status])
  @@index([shiftId])
  @@index([createdAt])
}

model CashierChargePayment {
  id       Int @id @default(autoincrement())
  chargeId Int

  amount Decimal                    @db.Decimal(12, 2)
  method CashierChargePaymentMethod @default(CASH)
  note   String?
  refNo  String?

  createdAt DateTime @default(now())

  /// Optional audit hooks (who/shift)
  shiftId   Int?
  cashierId Int?

  charge  CashierCharge @relation(fields: [chargeId], references: [id], onDelete: Cascade)
  shift   CashierShift? @relation(fields: [shiftId], references: [id], onDelete: SetNull)
  cashier User?         @relation("CashierChargePaymentsProcessed", fields: [cashierId], references: [id], onDelete: SetNull)

  @@index([chargeId])
  @@index([cashierId, createdAt])
}

model RiderRunVariance {
  id      Int  @id @default(autoincrement())
  runId   Int
  riderId Int
  shiftId Int?

  /// ✅ Receipt-based one-time lock (idempotency key)
  /// When cashier posts a shortage settlement for a receipt, we upsert using this.
  receiptId Int?        @unique
  receipt   RunReceipt? @relation(fields: [receiptId], references: [id], onDelete: SetNull)

  /// Expected cash based on rider check-in + remit logic
  expected Decimal @db.Decimal(12, 2)
  /// Actual cash na na-turnover kay cashier
  actual   Decimal @db.Decimal(12, 2)
  /// actual - expected (negative = shortage, positive = over)
  variance Decimal @db.Decimal(12, 2)

  note       String?
  status     RiderVarianceStatus @default(OPEN)
  createdAt  DateTime            @default(now())
  resolvedAt DateTime?

  /// Manager clearance (who/when/decision)
  managerApprovedAt   DateTime?
  managerApprovedById Int?
  resolution          RiderVarianceResolution?

  /// Rider acceptance (who/when) - required if resolution=CHARGE_RIDER
  riderAcceptedAt   DateTime?
  riderAcceptedById Int?

  run   DeliveryRun   @relation(fields: [runId], references: [id], onDelete: Cascade)
  rider Employee      @relation(fields: [riderId], references: [id], onDelete: Restrict)
  shift CashierShift? @relation(fields: [shiftId], references: [id], onDelete: SetNull)

  managerApprovedBy User?        @relation("ManagerApprovedVariances", fields: [managerApprovedById], references: [id], onDelete: SetNull)
  riderAcceptedBy   User?        @relation("RiderAcceptedVariances", fields: [riderAcceptedById], references: [id], onDelete: SetNull)
  RiderCharge       RiderCharge?

  @@index([runId, riderId, shiftId])
  @@index([runId])
  @@index([riderId])
  @@index([status])
  @@index([managerApprovedAt])
  @@index([riderAcceptedAt])
  @@index([receiptId])
}

enum OverrideKind {
  CAPACITY_EXCEED
  PRICE_BELOW_ALLOWED
  MANUAL_RETURN_ADJUST
  AR_APPROVE
}

// ────────────── Commercial Clearance System (CCS) ──────────────

enum ClearanceOrigin {
  CASHIER
  RIDER
}

// Claim = factual situation; non-decisional (cashier/rider declares)
enum ClearanceClaimType {
  /// Customer will pay later / remaining balance (requires customer)
  OPEN_BALANCE

  /// Bargain/discount request for remaining balance (customer optional)
  PRICE_BARGAIN

  /// Fallback bucket (optional but recommended)
  OTHER
}

enum ClearanceCaseStatus {
  // CCS v2.7 canonical statuses only:
  // - NEEDS_CLEARANCE: pending manager decision
  // - DECIDED: manager has issued a decision
  NEEDS_CLEARANCE
  DECIDED
}

// Manager decision (commercial consequence)
enum ClearanceDecisionKind {
  /// Waive remaining balance (discount override)
  APPROVE_DISCOUNT_OVERRIDE

  /// Approve pay-later / open balance (creates CustomerAr ledger)
  /// Requires customerId (enforced by app logic; schema keeps customer optional for other flows)
  APPROVE_OPEN_BALANCE

  APPROVE_HYBRID
  REJECT
  CANCEL_SALE
}

// Customer AR lifecycle (separate from OrderStatus/PARTIALLY_PAID)
enum CustomerArStatus {
  OPEN
  PARTIALLY_SETTLED
  SETTLED
  WAIVED
  CANCELLED
}

model ClearanceCase {
  id     Int                 @id @default(autoincrement())
  status ClearanceCaseStatus @default(NEEDS_CLEARANCE)
  origin ClearanceOrigin

  /// CCS v2.5: stable per-receipt idempotency key (SoT).
  /// Examples:
  /// - "PARENT:12345" (Order.id)
  /// - "ROAD:67890" (RunReceipt.id)
  receiptKey String @db.VarChar(64)

  // unified per customer obligation (nullable for walk-in no-customer)
  customerId Int?
  customer   Customer? @relation("CustomerClearanceCases", fields: [customerId], references: [id], onDelete: SetNull)

  // optional anchors (depends on world)
  orderId      Int?
  order        Order?       @relation("OrderClearanceCases", fields: [orderId], references: [id], onDelete: SetNull)
  runId        Int?
  run          DeliveryRun? @relation("RunClearanceCases", fields: [runId], references: [id], onDelete: SetNull)
  runReceiptId Int?
  runReceipt   RunReceipt?  @relation("ReceiptClearanceCases", fields: [runReceiptId], references: [id], onDelete: SetNull)

  // audit snapshot at flag time
  frozenTotal   Decimal @db.Decimal(12, 2)
  cashCollected Decimal @db.Decimal(12, 2)

  // who flagged (optional)
  flaggedById Int?
  flaggedBy   User?    @relation("ClearanceFlaggedBy", fields: [flaggedById], references: [id], onDelete: SetNull)
  flaggedAt   DateTime @default(now())

  note      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  claims    ClearanceClaim[]
  decisions ClearanceDecision[]

  @@unique([receiptKey])
  @@index([status])
  @@index([origin, flaggedAt])
  @@index([customerId])
  @@index([orderId])
  @@index([runId])
  @@index([runReceiptId])
}

model ClearanceClaim {
  id     Int                @id @default(autoincrement())
  caseId Int
  type   ClearanceClaimType

  // factual details (optional)
  requestedPayable Decimal? @db.Decimal(12, 2) // e.g. "57 lang"
  cashAvailable    Decimal? @db.Decimal(12, 2) // partial cash offered now
  detail           String?

  createdAt DateTime @default(now())

  clearanceCase ClearanceCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId, type])
}

model ClearanceDecision {
  id     Int                   @id @default(autoincrement())
  caseId Int
  kind   ClearanceDecisionKind

  // manager intent payload
  overrideDiscountApproved Decimal? @db.Decimal(12, 2) // force discount amount
  approvedPayable          Decimal? @db.Decimal(12, 2) // optional explicit payable
  arBalance                Decimal? @db.Decimal(12, 2) // recorded at decision time

  decidedById Int?
  decidedBy   User?    @relation("ClearanceDecidedBy", fields: [decidedById], references: [id], onDelete: SetNull)
  decidedAt   DateTime @default(now())

  returnToOrigin Boolean @default(false)
  note           String?

  createdAt DateTime @default(now())

  clearanceCase ClearanceCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  // back-relation (for CustomerAr.link)
  customerAr CustomerAr?

  @@index([caseId, decidedAt])
  @@index([kind])
}

// Customer A/R ledger (created ONLY when manager approves AR/hybrid)
model CustomerAr {
  id Int @id @default(autoincrement())

  customerId Int
  customer   Customer @relation("CustomerArLedger", fields: [customerId], references: [id], onDelete: Cascade)

  // audit link (optional but recommended)
  clearanceDecisionId Int?               @unique
  clearanceDecision   ClearanceDecision? @relation(fields: [clearanceDecisionId], references: [id], onDelete: SetNull)
  // optional anchors
  orderId             Int?
  order               Order?             @relation("OrderCustomerAr", fields: [orderId], references: [id], onDelete: SetNull)
  runId               Int?
  run                 DeliveryRun?       @relation("RunCustomerAr", fields: [runId], references: [id], onDelete: SetNull)

  principal Decimal          @db.Decimal(12, 2)
  balance   Decimal          @db.Decimal(12, 2)
  status    CustomerArStatus @default(OPEN)
  dueDate   DateTime?

  note      String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  settledAt DateTime?

  payments CustomerArPayment[]

  @@index([customerId, status])
  @@index([orderId])
  @@index([runId])
  @@index([createdAt])
}

model CustomerArPayment {
  id   Int        @id @default(autoincrement())
  arId Int
  ar   CustomerAr @relation(fields: [arId], references: [id], onDelete: Cascade)

  amount Decimal @db.Decimal(12, 2)
  note   String?
  refNo  String?

  // optional audit hooks (cashier shift)
  shiftId   Int?
  cashierId Int?
  shift     CashierShift? @relation("ShiftCustomerArPayments", fields: [shiftId], references: [id], onDelete: SetNull)
  cashier   User?         @relation("CustomerArPaymentsProcessed", fields: [cashierId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([arId])
  @@index([cashierId, createdAt])
}

model Province {
  id                Int               @id @default(autoincrement())
  name              String
  code              String?           @db.VarChar(16)
  isActive          Boolean           @default(true)
  municipalities    Municipality[]
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  addresses         CustomerAddress[]
  employeeAddresses EmployeeAddress[]

  @@unique([name]) // app also guards case-insensitive dupes
  @@index([isActive])
}

model Municipality {
  id       Int     @id @default(autoincrement())
  name     String
  code     String? @db.VarChar(16)
  isActive Boolean @default(true)

  provinceId Int
  province   Province @relation(fields: [provinceId], references: [id], onDelete: Cascade)

  barangays         Barangay[]
  addresses         CustomerAddress[]
  employeeAddresses EmployeeAddress[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provinceId, name])
  @@index([provinceId])
  @@index([isActive])
}

model Barangay {
  id       Int     @id @default(autoincrement())
  name     String
  code     String? @db.VarChar(16)
  isActive Boolean @default(true)

  municipalityId Int
  municipality   Municipality @relation(fields: [municipalityId], references: [id], onDelete: Cascade)

  zones             Zone[]
  landmarks         Landmark[]
  addresses         CustomerAddress[]
  employeeAddresses EmployeeAddress[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([municipalityId, name])
  @@index([municipalityId])
  @@index([isActive])
}

model Zone {
  id       Int     @id @default(autoincrement())
  name     String // e.g. "Purok 1", "Zone 3"
  isActive Boolean @default(true)

  barangayId Int
  barangay   Barangay @relation(fields: [barangayId], references: [id], onDelete: Cascade)

  addresses         CustomerAddress[]
  employeeAddresses EmployeeAddress[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([barangayId, name])
  @@index([barangayId])
  @@index([isActive])
}

model Landmark {
  id       Int     @id @default(autoincrement())
  name     String
  isActive Boolean @default(true)

  // tie to barangay (simplest). can make optional if you want cross-brgy landmarks.
  barangayId Int?
  barangay   Barangay? @relation(fields: [barangayId], references: [id], onDelete: SetNull)

  addresses         CustomerAddress[] @relation("LandmarkToAddresses")
  employeeAddresses EmployeeAddress[] @relation("LandmarkToEmployeeAddresses")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, barangayId])
  @@index([barangayId])
  @@index([isActive])
}

// ────────────── AUTH & RBAC (Minimal v1) ──────────────

enum UserRole {
  ADMIN
  CASHIER
  STORE_MANAGER
  EMPLOYEE
}

enum ManagerKind {
  OWNER
  STAFF
}

enum UserAuthState {
  PENDING_PASSWORD
  ACTIVE
}

enum CashDrawerTxnType {
  CASH_IN
  CASH_OUT
  DROP
  ADJUST
}

// ────────────── CASHIER SHIFT 2-STEP CLOSE (Patch 1) ──────────────
// Cashier submits close count → Manager final-closes (sets closedAt).
// Manager may require recount (disapprove) without final close.

enum CashierShiftStatus {
  PENDING_ACCEPT
  OPEN
  OPENING_DISPUTED
  SUBMITTED
  RECOUNT_REQUIRED
  FINAL_CLOSED
}

model User {
  id           Int           @id @default(autoincrement())
  email        String?       @unique
  passwordHash String? // password login for all roles
  pinHash      String? // legacy field; no longer used for login
  role         UserRole
  managerKind  ManagerKind?
  active       Boolean       @default(true)
  authState    UserAuthState @default(ACTIVE)
  authVersion  Int           @default(1)

  employeeId Int?      @unique
  employee   Employee? @relation(fields: [employeeId], references: [id], onDelete: SetNull)

  // Scoping & usage
  branches                        UserBranch[] // NEW
  shifts                          CashierShift[]         @relation("CashierShiftCashier")
  paymentsProcessed               Payment[]              @relation("UserPaymentsProcessed")
  cashDrawerTxnsCreated           CashDrawerTxn[]        @relation("UserCreatedDrawerTxns")
  managerApprovedVariances        RiderRunVariance[]     @relation("ManagerApprovedVariances")
  managerApprovedCashierVariances CashierShiftVariance[] @relation("ManagerApprovedCashierVariances")
  riderAcceptedVariances          RiderRunVariance[]     @relation("RiderAcceptedVariances")

  // Rider Charges ledger (OPTION B)
  riderChargesCreated          RiderCharge[]        @relation("RiderChargesCreatedBy")
  riderChargePaymentsProcessed RiderChargePayment[] @relation("RiderChargePaymentsProcessed")

  // Cashier Charges ledger (OPTION B)
  cashierCharges                 CashierCharge[]        @relation("CashierChargesOnUser")
  cashierChargesCreated          CashierCharge[]        @relation("CashierChargesCreatedBy")
  cashierChargePaymentsProcessed CashierChargePayment[] @relation("CashierChargePaymentsProcessed")

  // CCS back-relations
  clearanceCasesFlagged       ClearanceCase[]     @relation("ClearanceFlaggedBy")
  clearanceDecisionsMade      ClearanceDecision[] @relation("ClearanceDecidedBy")
  customerArPaymentsProcessed CustomerArPayment[] @relation("CustomerArPaymentsProcessed")

  // v2.6: who voided a receipt
  voidedRunReceipts RunReceipt[] @relation("RunReceiptVoidedBy")

  // ✅ NEW: manager/admin who final-closed a shift (audit trail)
  cashierShiftsFinalClosed CashierShift[] @relation("CashierShiftFinalClosedBy")

  // ✅ NEW: cashier who verified opening float
  cashierShiftsOpeningVerified CashierShift[] @relation("CashierShiftOpeningVerifiedBy")

  // Role lifecycle and immutable audit
  roleAssignments           UserRoleAssignment[] @relation("UserRoleAssignments")
  roleAssignmentsAuthored   UserRoleAssignment[] @relation("UserRoleAssignmentsChangedBy")
  roleAuditEvents           UserRoleAuditEvent[] @relation("UserRoleAuditEventsOnUser")
  roleAuditEventsAuthored   UserRoleAuditEvent[] @relation("UserRoleAuditEventsChangedBy")
  passwordResetTokens       PasswordResetToken[]
  employeeDocumentsUploaded EmployeeDocument[]   @relation("EmployeeDocumentsUploadedBy")

  lastLoginAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([role, active])
}

model UserRoleAssignment {
  id          Int       @id @default(autoincrement())
  userId      Int
  role        UserRole
  startedAt   DateTime  @default(now())
  endedAt     DateTime?
  reason      String?
  changedById Int?
  createdAt   DateTime  @default(now())

  user      User  @relation("UserRoleAssignments", fields: [userId], references: [id], onDelete: Cascade)
  changedBy User? @relation("UserRoleAssignmentsChangedBy", fields: [changedById], references: [id], onDelete: SetNull)

  @@index([userId, startedAt])
  @@index([role, endedAt])
  @@index([changedById, createdAt])
}

model UserRoleAuditEvent {
  id          Int      @id @default(autoincrement())
  userId      Int
  beforeRole  UserRole
  afterRole   UserRole
  reason      String?
  changedById Int?
  createdAt   DateTime @default(now())

  user      User  @relation("UserRoleAuditEventsOnUser", fields: [userId], references: [id], onDelete: Cascade)
  changedBy User? @relation("UserRoleAuditEventsChangedBy", fields: [changedById], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([changedById, createdAt])
  @@index([afterRole, createdAt])
}

model PasswordResetToken {
  id                 Int       @id @default(autoincrement())
  userId             Int
  tokenHash          String    @unique
  expiresAt          DateTime
  usedAt             DateTime?
  createdAt          DateTime  @default(now())
  requestedIp        String?   @db.VarChar(64)
  requestedUserAgent String?   @db.VarChar(300)
  consumedIp         String?   @db.VarChar(64)
  consumedUserAgent  String?   @db.VarChar(300)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([expiresAt])
  @@index([usedAt])
}

// (Removed) UserLocation — legacy mapping; replaced by UserBranch/Branch

// Cashier shift locking (required to finalize/pay/remit)
model CashierShift {
  id        Int  @id @default(autoincrement())
  cashierId Int
  branchId  Int? // TEMP: optional while no-branch mode

  openedAt      DateTime  @default(now())
  closedAt      DateTime?
  openingFloat  Decimal?  @db.Decimal(12, 2)
  closingTotal  Decimal?  @db.Decimal(12, 2)
  /// Denomination snapshot at shift close (audit). Example:
  /// { bills: { "1000": 3, "500": 2 }, coins: { "25": 4, "10": 0, "5": 2, "1": 10 } }
  closingDenoms Json?
  deviceId      String?   @db.VarChar(64)
  notes         String?

  // ✅ Shift state machine (OPEN requires cashier verification of opening float)
  status CashierShiftStatus @default(PENDING_ACCEPT)

  // ✅ Opening float acceptance (cashier recount)
  openingCounted      Decimal?  @db.Decimal(12, 2)
  openingVerifiedAt   DateTime?
  openingVerifiedById Int?
  openingDisputeNote  String?

  openingVerifiedBy  User?     @relation("CashierShiftOpeningVerifiedBy", fields: [openingVerifiedById], references: [id], onDelete: SetNull)
  cashierSubmittedAt DateTime?
  finalClosedById    Int?
  finalClosedBy      User?     @relation("CashierShiftFinalClosedBy", fields: [finalClosedById], references: [id], onDelete: SetNull)

  cashier         User                  @relation("CashierShiftCashier", fields: [cashierId], references: [id], onDelete: Cascade)
  branch          Branch?               @relation(fields: [branchId], references: [id], onDelete: SetNull)
  payments        Payment[]
  cashDrawerTxns  CashDrawerTxn[]
  riderVariances  RiderRunVariance[]
  cashierVariance CashierShiftVariance?

  // OPTION B: rider charge ledger payments recorded under this shift
  riderChargePayments RiderChargePayment[]

  // Cashier charge ledger (optional link to shift for audit)
  cashierCharges CashierCharge[]

  // Cashier charge ledger payments recorded under this shift (optional)
  cashierChargePayments CashierChargePayment[]

  // CCS back-relation
  customerArPayments CustomerArPayment[] @relation("ShiftCustomerArPayments")

  @@index([cashierId, closedAt])
  @@index([status])
  @@index([finalClosedById])
  @@index([openingVerifiedById])
}

model CashDrawerTxn {
  id          Int               @id @default(autoincrement())
  shift       CashierShift      @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  shiftId     Int
  type        CashDrawerTxnType
  amount      Decimal           @db.Decimal(12, 2)
  note        String?
  createdAt   DateTime          @default(now())
  createdBy   User?             @relation(name: "UserCreatedDrawerTxns", fields: [createdById], references: [id], onDelete: SetNull)
  createdById Int?

  @@index([shiftId])
  @@index([createdById])
}

model Branch {
  id     Int            @id @default(autoincrement())
  name   String         @unique
  users  UserBranch[]
  shifts CashierShift[]
}

model UserBranch {
  userId   Int
  branchId Int
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  branch   Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@id([userId, branchId])
  @@index([branchId])
}
