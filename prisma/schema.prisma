generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Product {
  id                 Int                 @id @default(autoincrement())
  name               String
  price              Float
  categoryId         Int?
  createdAt          DateTime            @default(now())
  description        String?
  imageUrl           String?
  imageKey           String?
  stock              Float?
  updatedAt          DateTime            @default(now()) @updatedAt
  brandId            Int?
  expirationDate     DateTime?
  imageTag           String?
  replenishAt        DateTime?
  dealerPrice        Float?
  srp                Float?
  allowPackSale      Boolean             @default(true)
  barcode            String?             @unique
  isActive           Boolean             @default(true)
  minStock           Float?
  packingStock       Int?
  sku                String?             @unique
  unitId             Int?
  packingUnitId      Int?
  locationId         Int?
  packingSize        Float?
  brand              Brand?              @relation(fields: [brandId], references: [id], onDelete: SetNull)
  category           Category?           @relation(fields: [categoryId], references: [id])
  location           Location?           @relation(fields: [locationId], references: [id], onDelete: SetNull)
  packingUnit        PackingUnit?        @relation("PackingUnit", fields: [packingUnitId], references: [id])
  unit               Unit?               @relation("RetailUnit", fields: [unitId], references: [id])
  productIndications ProductIndication[]
  productTags        ProductTag[]
  productTargets     ProductTarget[]
  saleItems          SaleItem[]
  tags               Tag[]               @relation("ProductTags")
  // back-relation to customer-specific pricing rules
  customerItemPrices CustomerItemPrice[] @relation("CustomerItemPricesOnProduct")
  orderItems         OrderItem[]
}

model Sale {
  id        Int        @id @default(autoincrement())
  createdAt DateTime   @default(now())
  total     Float
  items     SaleItem[]
}

model SaleItem {
  id        Int     @id @default(autoincrement())
  saleId    Int
  productId Int
  quantity  Int
  price     Float
  product   Product @relation(fields: [productId], references: [id])
  sale      Sale    @relation(fields: [saleId], references: [id])
}

model Category {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  brands      Brand[]
  indications Indication[]
  products    Product[]
  targets     Target[]
}

model Tag {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  productTags ProductTag[]
  products    Product[]    @relation("ProductTags")
}

model ProductTag {
  productId Int
  tagId     Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  tag       Tag     @relation(fields: [tagId], references: [id])

  @@id([productId, tagId])
}

model Brand {
  id         Int       @id @default(autoincrement())
  name       String
  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id])
  products   Product[]

  @@unique([name, categoryId])
}

model Indication {
  id                 Int                 @id @default(autoincrement())
  name               String
  categoryId         Int
  category           Category            @relation(fields: [categoryId], references: [id])
  productIndications ProductIndication[]

  @@unique([name, categoryId])
}

model ProductIndication {
  productId    Int
  indicationId Int
  indication   Indication @relation(fields: [indicationId], references: [id], onDelete: Cascade)
  product      Product    @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@id([productId, indicationId])
}

model Target {
  id         Int      @id @default(autoincrement())
  name       String
  categoryId Int
  category   Category @relation(fields: [categoryId], references: [id])

  productTargets ProductTarget[]

  @@unique([name, categoryId])
}

model ProductTarget {
  productId Int
  targetId  Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  target    Target  @relation(fields: [targetId], references: [id], onDelete: Cascade)

  @@id([productId, targetId])
}

model Unit {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  retailFor Product[] @relation("RetailUnit")
}

model PackingUnit {
  id         Int       @id @default(autoincrement())
  name       String    @unique
  packingFor Product[] @relation("PackingUnit")
}

model Location {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  products Product[]
}

// ────────────── ORDER SLIP (Milestone 1) ──────────────

model ReceiptCounter {
  id        Int      @id @default(1) // singleton (or per-branch later)
  current   Int      @default(0)
  updatedAt DateTime @updatedAt
}

model Customer {
  id            Int     @id @default(autoincrement())
  firstName     String
  middleName    String?
  lastName      String
  suffix        String?
  alias         String?
  phone         String? @unique
  email         String?
  isActive      Boolean @default(true)
  notes         String?
  creditLimit   Float?
  loyaltyPoints Int     @default(0)
  tier          String?

  addresses          CustomerAddress[]
  orders             Order[]
  cylinderLoans      CylinderLoan[]
  customerItemPrices CustomerItemPrice[]

  @@index([phone])
  @@index([alias])
  @@index([lastName, firstName])
}

model CustomerAddress {
  id             Int       @id @default(autoincrement())
  customerId     Int
  customer       Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  label          String
  line1          String
  barangay       String
  city           String
  province       String
  postalCode     String?
  landmark       String?
  geoLat         Float?
  geoLng         Float?
  photoUrl       String?
  photoKey       String?
  photoUpdatedAt DateTime?

  deliveryOrders Order[] @relation("OrderDeliveryAddress")
}

model CustomerItemPrice {
  id         Int       @id @default(autoincrement())
  customerId Int
  productId  Int
  unitKind   UnitKind
  mode       PriceMode
  value      Decimal   @db.Decimal(10, 2) // meaning depends on mode
  note       String?
  active     Boolean   @default(true)
  startsAt   DateTime?
  endsAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  product  Product  @relation("CustomerItemPricesOnProduct", fields: [productId], references: [id], onDelete: Cascade)

  @@unique([customerId, productId, unitKind, startsAt, endsAt])
  @@index([customerId, productId, unitKind])
  @@index([active, startsAt, endsAt])
}

model Order {
  id        Int         @id @default(autoincrement())
  orderCode String      @unique
  status    OrderStatus @default(UNPAID)

  // Channel: pickup vs delivery
  channel OrderChannel @default(PICKUP)

  // Snapshot totals (no discounts yet)
  subtotal            Float
  totalBeforeDiscount Float

  // Slip meta
  printCount Int      @default(1)
  printedAt  DateTime
  expiryAt   DateTime
  terminalId String?

  // Relations
  items      OrderItem[]
  payments   Payment[]
  customerId Int?
  customer   Customer?   @relation(fields: [customerId], references: [id])

  // (optional) Delivery address reference for delivery orders
  deliveryAddressId Int?
  deliveryAddress   CustomerAddress? @relation("OrderDeliveryAddress", fields: [deliveryAddressId], references: [id], onDelete: SetNull)
  deliverTo         String? // snapshot: "Name — full address"
  deliverPhone      String? // snapshot contact for rider
  deliverLandmark   String? // snapshot landmark text
  deliverGeoLat     Float? // snapshot coords (optional)
  deliverGeoLng     Float? // snapshot coords (optional)
  deliverPhotoUrl   String? // snapshot photo (optional)
  deliverPhotoKey   String? // snapshot photo storage key (optional)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Cashier locking ---
  lockedAt DateTime?
  lockedBy String? // cashier code/email/name
  lockNote String? // optional reason

  // --- Utang / Credit fields ---
  isOnCredit         Boolean   @default(false) // mark as utang/AR
  dueDate            DateTime? // optional promise-to-pay date
  releaseWithBalance Boolean   @default(false) // goods released before full payment
  releasedApprovedBy String? // who approved the release
  releasedAt         DateTime? // when goods left store

  // --- Delivery / Fulfillment ---
  fulfillmentStatus FulfillmentStatus? @default(NEW)
  dispatchedAt      DateTime?
  deliveredAt       DateTime?
  riderName         String? // free text for now; future: Staff/User relation

  // Receipt fields (set when PAID)
  paidAt    DateTime?
  receiptNo String?   @unique // set when PAID

  @@index([status, expiryAt])
  @@index([lockedAt])
  @@index([status])
  @@index([expiryAt])
  @@index([customerId])
  @@index([channel])
  @@index([fulfillmentStatus])
  @@index([deliveryAddressId])
  @@index([deliverGeoLat, deliverGeoLng])
}

model OrderItem {
  id      Int   @id @default(autoincrement())
  orderId Int
  order   Order @relation(fields: [orderId], references: [id])

  // Keep link to product but also snapshot name/price for immutability
  productId Int
  product   Product @relation(fields: [productId], references: [id])

  name      String
  qty       Decimal @db.Decimal(10, 2)
  unitPrice Decimal @db.Decimal(10, 2)
  lineTotal Decimal @db.Decimal(10, 2)

  // discount audit
  pricePolicy        String? // "BASE", "PER_ITEM", or "RULE:<id/type>"
  allowedUnitPrice   Decimal? @db.Decimal(10, 2)
  discountApprovedBy String? // if cashier priced below allowed

  // --- LPG minimal hooks (per line) ---
  isLpg            Boolean      @default(false)
  brandAtSale      String? // snapshot brand for receipt (esp. Catgas family)
  lpgSwapKind      LpgSwapKind?
  lpgEmptyReturned Float? // empties received at handover/delivery
  lpgLoaned        Float? // cylinders loaned (no empty returned)

  @@index([orderId])
}

model Payment {
  id        Int           @id @default(autoincrement())
  orderId   Int
  order     Order         @relation(fields: [orderId], references: [id])
  method    PaymentMethod
  amount    Float
  refNo     String? // GCash ref, last 4 of card, etc.
  createdAt DateTime      @default(now())

  @@index([orderId])
}

// Track borrowed LPG cylinders per customer
model CylinderLoan {
  id          Int       @id @default(autoincrement())
  customerId  Int
  customer    Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  brandFamily String // e.g. "CATGAS", "BRANDED" (can convert to enum later)
  qty         Float // allow fractional if needed (e.g., partial deposit logic later)
  openedAt    DateTime  @default(now())
  closedAt    DateTime?
  notes       String?

  @@index([customerId, closedAt])
}

// ── NEW (singleton counter for receipts) ────────────────────

enum PaymentMethod {
  CASH
  GCASH
  CARD
  SPLIT // optional: if you want a “meta” method; otherwise just record multiple rows
}

enum OrderStatus {
  DRAFT
  UNPAID
  PAID
  PARTIALLY_PAID
  CANCELLED
  VOIDED
}

enum UnitKind {
  RETAIL
  PACK
}

enum PriceMode {
  FIXED_PRICE // set the exact unit price
  FIXED_DISCOUNT // subtract a fixed amount (per unit)
  PERCENT_DISCOUNT // subtract % of base price (per unit)
}

// --- NEW: channel + fulfillment + LPG swap kinds ---
enum OrderChannel {
  PICKUP
  DELIVERY
}

enum FulfillmentStatus {
  NEW
  PICKING
  PACKING
  DISPATCHED
  DELIVERED
  ON_HOLD
}

enum LpgSwapKind {
  REFILL
  SWAP_CATGAS
  UPGRADE_BRANDED
}
