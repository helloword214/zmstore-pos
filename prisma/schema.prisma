generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Product {
  id                 Int                 @id @default(autoincrement())
  name               String
  price              Float
  categoryId         Int?
  createdAt          DateTime            @default(now())
  description        String?
  imageUrl           String?
  imageKey           String?
  stock              Float?
  updatedAt          DateTime            @default(now()) @updatedAt
  brandId            Int?
  expirationDate     DateTime?
  imageTag           String?
  replenishAt        DateTime?
  dealerPrice        Float?
  srp                Float?
  allowPackSale      Boolean             @default(true)
  barcode            String?             @unique
  isActive           Boolean             @default(true)
  minStock           Float?
  packingStock       Int?
  sku                String?             @unique
  unitId             Int?
  packingUnitId      Int?
  locationId         Int?
  packingSize        Float?
  brand              Brand?              @relation(fields: [brandId], references: [id], onDelete: SetNull)
  category           Category?           @relation(fields: [categoryId], references: [id])
  location           Location?           @relation(fields: [locationId], references: [id], onDelete: SetNull)
  packingUnit        PackingUnit?        @relation("PackingUnit", fields: [packingUnitId], references: [id])
  unit               Unit?               @relation("RetailUnit", fields: [unitId], references: [id])
  productIndications ProductIndication[]
  productTags        ProductTag[]
  productTargets     ProductTarget[]
  saleItems          SaleItem[]
  tags               Tag[]               @relation("ProductTags")
  // back-relation to customer-specific pricing rules
  customerItemPrices CustomerItemPrice[] @relation("CustomerItemPricesOnProduct")
  orderItems         OrderItem[]

  // back-relations for new models
  stockMovements StockMovement[]
  runAdhocSales  RunAdhocSale[]
}

model Sale {
  id        Int        @id @default(autoincrement())
  createdAt DateTime   @default(now())
  total     Float
  items     SaleItem[]
}

model SaleItem {
  id        Int     @id @default(autoincrement())
  saleId    Int
  productId Int
  quantity  Int
  price     Float
  product   Product @relation(fields: [productId], references: [id])
  sale      Sale    @relation(fields: [saleId], references: [id])
}

model Category {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  brands      Brand[]
  indications Indication[]
  products    Product[]
  targets     Target[]
}

model Tag {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  productTags ProductTag[]
  products    Product[]    @relation("ProductTags")
}

model ProductTag {
  productId Int
  tagId     Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  tag       Tag     @relation(fields: [tagId], references: [id])

  @@id([productId, tagId])
}

model Brand {
  id         Int       @id @default(autoincrement())
  name       String
  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id])
  products   Product[]

  @@unique([name, categoryId])
}

model Indication {
  id                 Int                 @id @default(autoincrement())
  name               String
  categoryId         Int
  category           Category            @relation(fields: [categoryId], references: [id])
  productIndications ProductIndication[]

  @@unique([name, categoryId])
}

model ProductIndication {
  productId    Int
  indicationId Int
  indication   Indication @relation(fields: [indicationId], references: [id], onDelete: Cascade)
  product      Product    @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@id([productId, indicationId])
}

model Target {
  id         Int      @id @default(autoincrement())
  name       String
  categoryId Int
  category   Category @relation(fields: [categoryId], references: [id])

  productTargets ProductTarget[]

  @@unique([name, categoryId])
}

model ProductTarget {
  productId Int
  targetId  Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  target    Target  @relation(fields: [targetId], references: [id], onDelete: Cascade)

  @@id([productId, targetId])
}

model Unit {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  retailFor Product[] @relation("RetailUnit")
}

model PackingUnit {
  id         Int       @id @default(autoincrement())
  name       String    @unique
  packingFor Product[] @relation("PackingUnit")
}

model Location {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  products Product[]
}

// ────────────── ORDER SLIP (Milestone 1) ──────────────

model ReceiptCounter {
  id        Int      @id @default(1) // singleton (or per-branch later)
  current   Int      @default(0)
  updatedAt DateTime @updatedAt
}

model Customer {
  id            Int     @id @default(autoincrement())
  firstName     String
  middleName    String?
  lastName      String
  suffix        String?
  alias         String?
  phone         String? @unique
  email         String?
  isActive      Boolean @default(true)
  notes         String?
  creditLimit   Float?
  loyaltyPoints Int     @default(0)
  tier          String?

  addresses          CustomerAddress[]
  orders             Order[]
  cylinderLoans      CylinderLoan[]
  customerItemPrices CustomerItemPrice[]

  @@index([phone])
  @@index([alias])
  @@index([lastName, firstName])
}

model CustomerAddress {
  id             Int       @id @default(autoincrement())
  customerId     Int
  customer       Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  label          String
  line1          String
  barangay       String
  city           String
  province       String
  postalCode     String?
  landmark       String?
  geoLat         Float?
  geoLng         Float?
  photoUrl       String?
  photoKey       String?
  photoUpdatedAt DateTime?

  deliveryOrders Order[] @relation("OrderDeliveryAddress")
}

model CustomerItemPrice {
  id         Int       @id @default(autoincrement())
  customerId Int
  productId  Int
  unitKind   UnitKind
  mode       PriceMode
  value      Decimal   @db.Decimal(10, 2) // meaning depends on mode
  note       String?
  active     Boolean   @default(true)
  startsAt   DateTime?
  endsAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  product  Product  @relation("CustomerItemPricesOnProduct", fields: [productId], references: [id], onDelete: Cascade)

  @@unique([customerId, productId, unitKind, startsAt, endsAt])
  @@index([customerId, productId, unitKind])
  @@index([active, startsAt, endsAt])
}

model Order {
  id        Int         @id @default(autoincrement())
  orderCode String      @unique
  status    OrderStatus @default(UNPAID)

  // Channel: pickup vs delivery
  channel OrderChannel @default(PICKUP)

  // Snapshot totals (no discounts yet)
  subtotal            Float
  totalBeforeDiscount Float

  // Slip meta
  printCount Int      @default(1)
  printedAt  DateTime
  expiryAt   DateTime
  terminalId String?

  // Relations
  items      OrderItem[]
  payments   Payment[]
  customerId Int?
  customer   Customer?   @relation(fields: [customerId], references: [id])

  // (optional) Delivery address reference for delivery orders
  deliveryAddressId Int?
  deliveryAddress   CustomerAddress? @relation("OrderDeliveryAddress", fields: [deliveryAddressId], references: [id], onDelete: SetNull)
  deliverTo         String? // snapshot: "Name — full address"
  deliverPhone      String? // snapshot contact for rider
  deliverLandmark   String? // snapshot landmark text
  deliverGeoLat     Float? // snapshot coords (optional)
  deliverGeoLng     Float? // snapshot coords (optional)
  deliverPhotoUrl   String? // snapshot photo (optional)
  deliverPhotoKey   String? // snapshot photo storage key (optional)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Cashier locking ---
  lockedAt DateTime?
  lockedBy String? // cashier code/email/name
  lockNote String? // optional reason

  // --- Utang / Credit fields ---
  isOnCredit         Boolean   @default(false) // mark as utang/AR
  dueDate            DateTime? // optional promise-to-pay date
  releaseWithBalance Boolean   @default(false) // goods released before full payment
  releasedApprovedBy String? // who approved the release
  releasedAt         DateTime? // when goods left store

  // --- Delivery / Fulfillment ---
  fulfillmentStatus FulfillmentStatus? @default(NEW)
  dispatchedAt      DateTime?
  deliveredAt       DateTime?
  riderName         String? // free text for now; future: Staff/User relation

  // --- Staging (Delivery Dispatch Staging) ---
  stagedAt        DateTime?
  riderId         Int? // relational rider (Employee)
  vehicleId       Int? // relational vehicle
  vehicleName     String? // snapshot (for ticket history)
  loadoutSnapshot Json? // [{ productId, name, qty, unit? }]

  // Named relations to avoid ambiguity
  rider   Employee? @relation("OrderRider", fields: [riderId], references: [id], onDelete: SetNull)
  vehicle Vehicle?  @relation("OrderVehicle", fields: [vehicleId], references: [id], onDelete: SetNull)

  // Back-relations
  overrideLogs OverrideLog[] @relation("OrderOverrideLogs")

  // Receipt fields (set when PAID)
  paidAt    DateTime?
  receiptNo String?   @unique // set when PAID

  // Back-relation for DeliveryRunOrder join table
  runOrders DeliveryRunOrder[] @relation("OrderRunLinks")

  remitGroup   String?  @db.VarChar(64) // group tag for rider remit batches

  /// If this order was created from a rider “sold from load” row during a remit,
  /// link it back to the main DELIVERY order being remitted.
  remitParentId    Int?      
  remitParent      Order?    @relation("RemitParentChildren", fields: [remitParentId], references: [id])

  /// Children created from the parent remit
  remitChildren    Order[]   @relation("RemitParentChildren")
  
  @@index([remitGroup])
  @@index([status, expiryAt])
  @@index([lockedAt])
  @@index([status])
  @@index([expiryAt])
  @@index([customerId])
  @@index([channel])
  @@index([fulfillmentStatus])
  @@index([deliveryAddressId])
  @@index([deliverGeoLat, deliverGeoLng])
  @@index([riderId])
  @@index([vehicleId])
}

model OrderItem {
  id      Int   @id @default(autoincrement())
  orderId Int
  order   Order @relation(fields: [orderId], references: [id])

  // Keep link to product but also snapshot name/price for immutability
  productId Int
  product   Product @relation(fields: [productId], references: [id])

  name      String
  qty       Decimal @db.Decimal(10, 2)
  unitPrice Decimal @db.Decimal(10, 2)
  lineTotal Decimal @db.Decimal(10, 2)

  // DB already has this; make it visible to Prisma
  unitKind UnitKind?

  // discount audit
  pricePolicy        String? // "BASE", "PER_ITEM", or "RULE:<id/type>"
  allowedUnitPrice   Decimal? @db.Decimal(10, 2)
  discountApprovedBy String? // if cashier priced below allowed

  // --- LPG minimal hooks (per line) ---
  isLpg            Boolean      @default(false)
  brandAtSale      String? // snapshot brand for receipt (esp. Catgas family)
  lpgSwapKind      LpgSwapKind?
  lpgEmptyReturned Float? // empties received at handover/delivery
  lpgLoaned        Float? // cylinders loaned (no empty returned)

  @@index([orderId])
}

model Payment {
  id        Int           @id @default(autoincrement())
  orderId   Int
  order     Order         @relation(fields: [orderId], references: [id])
  method    PaymentMethod
  amount    Float
  refNo     String? // GCash ref, last 4 of card, etc.
  createdAt DateTime      @default(now())

  /// NEW: what the cashier/rider actually handed
  tendered  Decimal? @db.Decimal(10,2)
  /// NEW: change given back
  change    Decimal? @db.Decimal(10,2)

  @@index([orderId])
}

// Track borrowed LPG cylinders per customer
model CylinderLoan {
  id          Int       @id @default(autoincrement())
  customerId  Int
  customer    Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  brandFamily String // e.g. "CATGAS", "BRANDED" (can convert to enum later)
  qty         Float // allow fractional if needed (e.g., partial deposit logic later)
  openedAt    DateTime  @default(now())
  closedAt    DateTime?
  notes       String?

  @@index([customerId, closedAt])
}

// ── NEW (singleton counter for receipts) ────────────────────

enum PaymentMethod {
  CASH
  GCASH
  CARD
  SPLIT // optional: if you want a “meta” method; otherwise just record multiple rows
}

enum OrderStatus {
  DRAFT
  UNPAID
  PAID
  PARTIALLY_PAID
  CANCELLED
  VOIDED
}

enum UnitKind {
  RETAIL
  PACK
}

enum PriceMode {
  FIXED_PRICE // set the exact unit price
  FIXED_DISCOUNT // subtract a fixed amount (per unit)
  PERCENT_DISCOUNT // subtract % of base price (per unit)
}

// --- NEW: channel + fulfillment + LPG swap kinds ---
enum OrderChannel {
  PICKUP
  DELIVERY
}

enum FulfillmentStatus {
  NEW
  STAGED
  PICKING
  PACKING
  DISPATCHED
  DELIVERED
  ON_HOLD
}

enum LpgSwapKind {
  REFILL
  SWAP_CATGAS
  UPGRADE_BRANDED
}

// ────────────── NEW: Workforce & Fleet ──────────────

model Employee {
  id        Int          @id @default(autoincrement())
  firstName String
  lastName  String
  alias     String?
  phone     String?      @unique
  email     String?      @unique
  role      EmployeeRole @default(STAFF)
  active    Boolean      @default(true)

  defaultVehicleId Int?
  defaultVehicle   Vehicle? @relation("DefaultVehicle", fields: [defaultVehicleId], references: [id], onDelete: SetNull)

  // Back-relations
  ordersAsRider Order[]       @relation("OrderRider")
  runsAsRider   DeliveryRun[] @relation("RunRider")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([role, active])
}

enum EmployeeRole {
  STAFF
  RIDER
  MANAGER
}

model Vehicle {
  id            Int         @id @default(autoincrement())
  name          String
  type          VehicleType
  capacityUnits Float? // e.g., "LPG unit slots" default capacity
  notes         String?
  active        Boolean     @default(true)

  // backrefs
  defaultForEmployees Employee[]               @relation("DefaultVehicle")
  usedOnOrders        Order[]                  @relation("OrderVehicle")
  runs                DeliveryRun[]            @relation("RunVehicle")
  capacityProfiles    VehicleCapacityProfile[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, type])
  @@index([active])
}

enum VehicleType {
  TRICYCLE
  MOTORCYCLE
  SIDECAR
  MULTICAB
  VAN
  OTHER
}

// Optional finer-grained capacity per product/tag/category
model VehicleCapacityProfile {
  id        Int    @id @default(autoincrement())
  vehicleId Int
  key       String // e.g., "TAG:LPG", "CAT:11KG", "PRODUCT:123"
  maxUnits  Float

  vehicle Vehicle @relation(fields: [vehicleId], references: [id], onDelete: Cascade)

  @@unique([vehicleId, key])
  @@index([vehicleId])
}

// ────────────── NEW: Stock Movements for Loadout (Milestone 2) ──────────────

model StockMovement {
  id           Int               @id @default(autoincrement())
  type         StockMovementType
  productId    Int
  qty          Decimal           @db.Decimal(12, 3)
  refKind      StockRefKind?
  refId        Int? // Order.id or DeliveryRun.id depending on refKind
  locationFrom String?
  locationTo   String?

  createdAt DateTime @default(now())
  notes     String?

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([type, productId])
  @@index([refKind, refId])
}

enum StockMovementType {
  LOADOUT_OUT // Movement Out: Loadout to rider
  RETURN_IN // Movement In: Return from rider
  ADHOC_SALE_OUT // Optional: ad-hoc sale deduction (from run loadout)
}

enum StockRefKind {
  ORDER
  RUN
}

// ────────────── NEW: Delivery Runs (Milestone 3) ──────────────

model DeliveryRun {
  id              Int       @id @default(autoincrement())
  runCode         String    @unique
  status          RunStatus @default(PLANNED)
  riderId         Int?
  vehicleId       Int?
  loadoutSnapshot Json? // snapshot at dispatch time
  notes           String?

  createdAt    DateTime  @default(now())
  dispatchedAt DateTime?
  closedAt     DateTime?

  rider   Employee? @relation("RunRider", fields: [riderId], references: [id], onDelete: SetNull)
  vehicle Vehicle?  @relation("RunVehicle", fields: [vehicleId], references: [id], onDelete: SetNull)

  orders       DeliveryRunOrder[]
  adhocSales   RunAdhocSale[]
  overrideLogs OverrideLog[]      @relation("RunOverrideLogs")

  @@index([status])
  @@index([riderId])
  @@index([vehicleId])
}

enum RunStatus {
  PLANNED
  DISPATCHED
  CLOSED
  CANCELLED
}

// Join table: many orders per run
model DeliveryRunOrder {
  runId    Int
  orderId  Int
  sequence Int? // optional stop ordering

  run   DeliveryRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  order Order       @relation("OrderRunLinks", fields: [orderId], references: [id], onDelete: Cascade)

  @@id([runId, orderId])
  @@index([orderId])
}

// Minimal ad-hoc sale lines against a run loadout
model RunAdhocSale {
  id        Int      @id @default(autoincrement())
  runId     Int
  productId Int
  qty       Decimal  @db.Decimal(12, 3)
  unitPrice Decimal  @db.Decimal(10, 2)
  lineTotal Decimal  @db.Decimal(12, 2)
  createdAt DateTime @default(now())

  run     DeliveryRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  product Product     @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([runId])
  @@index([productId])
}

// ────────────── NEW: Permissions & Overrides (Milestone 4) ──────────────
model OverrideLog {
  id         Int          @id @default(autoincrement())
  kind       OverrideKind
  orderId    Int?
  runId      Int?
  approvedBy String // PIN/name or user code
  reason     String?
  createdAt  DateTime     @default(now())

  // Named relations + back-relations exist on Order/DeliveryRun
  order Order?       @relation("OrderOverrideLogs", fields: [orderId], references: [id], onDelete: SetNull)
  run   DeliveryRun? @relation("RunOverrideLogs", fields: [runId], references: [id], onDelete: SetNull)

  @@index([orderId])
  @@index([runId])
  @@index([kind, createdAt])
}

enum OverrideKind {
  CAPACITY_EXCEED
  PRICE_BELOW_ALLOWED
  MANUAL_RETURN_ADJUST
}
